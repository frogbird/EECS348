import common
import time

class variables:
	counter=0

def sudoku_backtracking(sudoku):
	# PUT YOUR CODE HERE
	# access the sudoku using "sudoku[y][x]"
	# y between 0 and 9
	# x between 0 and 9
	# function must return the number of permutations performed
	# the use of variables.counter to keep track of the worlds 
	# explored is optional but recommended 
	variables.counter=0
	# variables.counter+=1000000

	return bt_recurse(sudoku)


def bt_recurse(current_board):
	variables.counter += 1
	empty = []

	print variables.counter

	# find first open spot

	first_zero = None

	for i in range(0, 9):
		for j in range(0, 9):
			if(current_board[i][j] == 0):
				first_zero = (i, j)
				break
		break


	if(first_zero != None):
		for z in range(1, 10):
			if(common.can_yx_be_z(current_board, first_zero[0], first_zero[1], z)):
				new_board = [q[:] for q in current_board]
				new_board[first_zero[0]][first_zero[1]] = z
				bt_recurse(new_board)

	else:
		for i in range(0, 9):
			for j in range(0, 9):
				
	return variables.counter

def sudoku_forwardchecking(sudoku):
	# PUT YOUR CODE HERE
	# access the sudoku using "sudoku[y][x]"
	# y between 0 and 9
	# x between 0 and 9
	# function must return the number of permutations performed
	# the use of variables.counter to keep track of the worlds 
	# explored is optional but recommended 
	variables.counter=0
	variables.counter+=1000000
	return variables.counter

def sudoku_mrv(sudoku):
	# PUT YOUR CODE HERE
	# access the sudoku using "sudoku[y][x]"
	# y between 0 and 9
	# x between 0 and 9
	# function must return the number of permutations performed
	# the use of variables.counter to keep track of the worlds 
	# explored is optional but recommended 
	variables.counter=0
	variables.counter+=1000000
	return variables.counter
